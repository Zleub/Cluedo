<dom-module id="adebray-cluedo">
	<template>
		<style include="iron-flex iron-flex-alignment"></style>
		<style>
			:host {
				display: block;
				margin: 4px;
				padding: 8px;
				@apply(--layout-vertical);
				@apply(--layout-center);
			}

			/*paper-input {
				width: 800px;
			}*/

			paper-button {
				display: flex;
			}

			section {
				max-width: 800px;
			}

		</style>

		<!-- <iron-ajax
		  auto
		  url="http://api.adebray.ovh/story/0"
		  handle-as="json"
		  on-response="handleResponse">
		</iron-ajax> -->
		<iron-ajax
		  auto
		  url="__api_url__/test"
		  handle-as="json"
		  on-response="handleTS"
		  on-error="handleTS">
		</iron-ajax>
		<iron-ajax
		  auto
		  url="../.ascii_logo"
		  handle-as="text"
		  on-response="handleLogo">
		</iron-ajax>

		<prism-highlighter></prism-highlighter>
		<app-drawer id="drawer" style="z-index: 12;" swipe-open>
			<template is="dom-repeat" items="{{getSections()}}" index-as="index">
				<paper-button raised on-tap="changeLocation">{{item}}</paper-button>
			</template>
			<!-- <paper-button raised on-tap="changeLocation">Data</paper-button>
			<paper-button raised on-tap="changeLocation">Story</paper-button> -->
		</app-drawer>

		<app-location route="{{route}}" use-hash-as-path></app-location>
		<app-route
			route="{{route}}"
			pattern="/:page"
			data="{{data}}"
			tail="{{tail}}">
		</app-route>

		<iron-pages selected="{{route.path}}" attr-for-selected="id">
			<section id=scene>
				<div class="horizontal layout">
					<paper-icon-button icon="menu" on-tap="openDrawer"></paper-icon-button>
					<div class="flex horizontal layout end-justified">
						<pre>{{logo}}</pre>
					</div>
				</div>
				<adebray-dialog id="dialog"></adebray-dialog>
				<canvas id=canvas width="800" height="400"></canvas>
				<paper-button on-tap=run>Run</paper-button>
				<!-- <paper-textarea></paper-textarea> -->
				<!-- <adebray-graphql></adebray-graphql> -->
				<paper-button on-tap=toggle>TaleSpin Response</paper-button>
				<iron-collapse id=collapse>
					<marked-element markdown={{_toJSON(ts)}}></marked-element>
				</iron-collapse>
			</section>
			<section id=music>
				<iron-ajax
				  auto
				  url="../drumkit/snare/snare-top4.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>
				<iron-ajax
				  auto
				  url="../drumkit/snare/snare-top25.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>
				<iron-ajax
				  auto
				  url="../drumkit/kick/kick20.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>
				<iron-ajax
				  auto
				  url="../drumkit/hihat/closed-hihat/chh6.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>
				<iron-ajax
				  auto
				  url="../drumkit/hihat/foot-hihat/fhh6.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>
				<iron-ajax
				  auto
				  url="../drumkit/crash/crash8.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>
				<iron-ajax
				  auto
				  url="../drumkit/ride/ride-mid-in8.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>
				<iron-ajax
				  auto
				  url="../voice.wav"
				  handle-as="arraybuffer"
				  on-response="handleMusic">
				</iron-ajax>

				<paper-button on-tap=music>Run</paper-button>

			</section>
			<!-- <section id=story>c
				<h2>Story</h2>
				<adebray-graphql></adebray-graphql> -->
				<!-- <div>{{ts.personae}}</div> -->
				<!-- <div>{{ts.World.facts}}</div> -->
				<!-- <marked-element markdown={{_toJSON(ts)}}></marked-element> -->
			<!-- </section> -->
		</iron-pages>
	</template>
	<script>
	Polymer({
		is: 'adebray-cluedo',

		properties: {
			track: Object
		},

		getSections: function () {
			return Array.from(this.querySelectorAll('section')).map( e => e.id )
		},

		_toJSON: function (e) {
			return '```\n' + JSON.stringify(e, null, "  ") + '\n```'
		},

		logError: function (e) {
			console.log('error', e)
		},

		openDrawer: function (e) {
			this.$.drawer.toggle()
		},

		changeLocation: function (e) {
			let path = e.target.innerText.trim().toLowerCase()
			location = '#' + path
		},

		handleLogo: function (e) {
			console.log(e.detail.response)
			this.set('logo', e.detail.response)
		},

		handleResponse: function (e) {
			this.set('data', e.detail.response)
		},

		handleTS: function (e) {
			console.log(e)
			this.set('ts', e.detail.response)
			console.log(this.ts)
		},

		handleMusic: function (e) {
			var name = e.target.url.match(/.+\/(.+)\..+$/)[1]
	 		var data = e.detail.response;
			context.decodeAudioData(data, function(buffer) {

			if(
				window[name] !== undefined ||
				name === 'undefined' ||
				name.match(/^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|null|this|true|void|with|break|catch|class|const|false|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/)
			) {
				name = 'sampleupload_' + (name || (new Date()).getTime());
			}

			window[name] = buffer;

			if(name.match(/\/|\-|\~|\%|\,|\.|\;|\:|\!|\@|\#|\^|\&|\*|\(|\)|\\|\ /)) {
				console.log('The AudioBuffer `window["' + name + '"]` is ready for you to use.');
			} else {
				console.log('The AudioBuffer `' + name + '` is ready for you to use.');
			}

			}, function(e) {
			console.log('There was an error decoding your file (make sure it\'s a .wav file!)');
			console.log(e);
			});
		},

		toggle: function (e) {
			this.$.collapse.toggle()
		},

		music: function () {
			let tracks = [
				{
					name: 'foot hat',
					track: new track(window[`fhh6`]).beat(4).vol(0.3)
				},
				{
					name: 'snare1',
					track: new track(window[`snare-top4`]).beat(1).vol(0).in(20).beat(
						1, 1, 1, 3
					).vol(
						rf(0, .2), rf(0, .2), rf(0, .2), rf(0, .2)
					)
				},
				{
					name: 'snare2',
					track: new track(window[`snare-top25`]).beat(1).vol(0).in(30).beat(12).vol(0.3).in(60).beat(6, 3, 6, 3, 3, 3)
				},
				// {
				// 	name: 'crash',
				// 	track: new track(window[`crash8`]).beat(16).nl(16).vol(0.3)
				// },
				{
					name: 'ride',
					track: new track(window["ride-mid-in8"]).beat(1).vol(0).in(24).beat(21, 3).nl(12).vol(0.3)
				},
				{
					name: 'kick',
					track: new track(window[`kick20`]).beat(1).vol(0).in(24).beat(8, 16, 8).vol(0.3)
				},
				{
					name: 'bass',
					track: new track().saw().merge(
						new track().square()
					).nl(rf(1.8, 2.2), rf(1.8, 2.2), rf(1.8, 2.2)).notes(
						66, 73, 81,
						66, 73, 81,
						66, 74, 83,
						66, 74, 83,
						66, 74, 68, 76, 78, 73
					).trans(-36).vol(0.4).beat(
						8, 4, 4,
						4, 2, 2,
						8, 4, 4,
						4, 2, 2,
						2, 4, 2, 4, 2, 4
					).lp(33, 0, 1) //.adsr(0, 1, 1, 0)
				},
				// {
				// 	name: 'chords',
				// 	track: new track().sine().nl(1).notes(
				// 		walk.locrian(66)
				// 	).vol(0.01).beat(1, 1, 2)
				// }
			]

			// tracks.forEach( e => {
			// 	let child = document.createElement('adebray-volume')
			// 	child.track = e
			// 	this.$.music.appendChild(child)
			// })

			let bass = tracks.find(e => e.name == 'bass').track

			var gui = new dat.GUI()
			var controller = gui.add(bass, '_volume').min(0).max(1).step(0.01)
			controller.onChange( (value) => {
				bass.vol(value)
			} )

			// this.set('track', t)
			// console.log(this.track)
		},

		run: function (e) {

			let {renderer, scene, camera, update_stack} = Scene(this.$.canvas)


			var spotLight1 = new THREE.SpotLight( 0xaeaeff, 1 );
			spotLight1.position.set( 25, 25, 25 );
			spotLight1.castShadow = true;
			spotLight1.shadow.mapSize.width = 1024;
			spotLight1.shadow.mapSize.height = 1024;
			spotLight1.shadow.camera.near = 1;
			spotLight1.shadow.camera.far = 1000;
			spotLight1.shadow.camera.fov = 30;
			spotLight1.angle = 0.5
			scene.add( spotLight1 );

			// var spotLightHelper = new THREE.SpotLightHelper( spotLight1 );
			// scene.add( spotLightHelper );

			update_stack.push(({clock}) => {
				let time = clock.getElapsedTime() * 50
				spotLight1.position.set(
					Math.cos(time / 200) * 40,
					50,
					Math.sin(time / 200) * 40
				)
			})

			scene.dialog = this.$.dialog

			var light = new THREE.AmbientLight( 0xa0a0a0, 1000 );
			// light.position = new THREE.Vector3(0, 100, 0);
			scene.add( light );


			// let geometry = new THREE.BoxGeometry( 1, 1, 1 )
			let pieces = [
				{ w: 2, h: 2, d: 2 },
				{ w: 2, h: 2, d: 2 },
				{ w: 2, h: 2, d: 2 },
				{ w: 2, h: 2, d: 2 },
				{ w: 2, h: 2, d: 2 },

				// { w: 5, h: 1, d: 5 },
				// { w: 5, h: 5, d: 1 },
				// { w: 1, h: 5, d: 5 },
				// { w: 3, h: 2, d: 3 },
				// { w: 3, h: 3, d: 2 },
				// { w: 2, h: 3, d: 3 },
				//
				// { w: 2, h: 2, d: 2 },
				// { w: 2, h: 2, d: 2 },
				// { w: 2, h: 2, d: 2 },
				// { w: 2, h: 2, d: 2 },
				// { w: 2, h: 2, d: 2 },
				//
				// { w: 5, h: 1, d: 5 },
				// { w: 5, h: 5, d: 1 },
				// { w: 1, h: 5, d: 5 },
				// { w: 3, h: 2, d: 3 },
				// { w: 3, h: 3, d: 2 },
				// { w: 2, h: 3, d: 3 },
				// [
				// 	{
				// 		x: 1,
				// 		w: 3, h: 1, d: 1
				// 	},
				// 	{
				// 		w: 1, h: 1, d: 1
				// 	},
				// 	{
				// 		y: 1,
				// 		w: 1, h: 1, d: 1
				// 	},
				// 	{
				// 		z: 1,
				// 		w: 1, h: 1, d: 1
				// 	},
				// 	{
				// 		z: 1,
				// 		w: 1, h: 1, d: 3
				// 	},
				// 	{
				// 		y:2, z: 3,
				// 		w: 1, h: 3, d: 3
				// 	},
				// 	{
				// 		y: 3,
				// 		w: 5, h: 1, d: 3
				// 	},
				// ]
			]
			let s = (x, y, z) => x ** 2 + y ** 2 + z ** 2
			let f = p => {
				if (!(p instanceof Array)) {
					let geometry = new THREE.BoxGeometry(p.w, p.h, p.d)
					geometry.translate(p.w / 2, p.h / 2, p.d / 2)
					let material = new THREE.MeshPhongMaterial( {
						color: new THREE.Color(p.w, p.h, p.d),
						// wireframe: true
					} )
					let o = new THREE.Mesh(geometry, material)
					o.position.x = p.x || 0
					o.position.y = p.y || 0
					o.position.z = p.z || 0

					let data = []
					for (var x = 0; x < p.w; x++) {
						data[x] = []
						for (var y = 0; y < p.h; y++) {
							data[x][y] = []
							for (var z = 0; z < p.d; z++) {
								data[x][y][z] = true
							}
						}
					}

					return [data, o]
				}
				else {
					let g = new THREE.Group()
					p.map(f).forEach(e => g.add(e))
					return g
				}
			}
			let data = piece => (_x, _y, _z) => {
				return piece.reduce( (p, e, x) => {
					return p + e.reduce((p, e, y) => {
						return p + e.reduce( (p, e, z) => p + (e ? s(x + _x, y + _y, z + _z) : 0), 0)
					}, 0)
				}, 0)
			}
			let map_size = 20
			let map = []
			let empty = map
			for (var x = 0; x < 20; x++) {
				map[x] = []
				for (var y = 0; y < 20; y++) {
					map[x][y] = []
					for (var z = 0; z < 20; z++) {
						map[x][y][z] = false
					}
				}
			}
			let write = (map, [piece, object]) => (_x, _y, _z) => {
				piece.forEach((e, x) => {
					e.forEach((e, y) => {
						e.forEach((e, z) => {
							// console.log(e)
							if (!map[x + _x][y + _y][z + _z])
								map[x + _x][y + _y][z + _z] = (e ? piece : false)
							// scene.add(object)
						})
					})
				})
			}
			let remove = (map, [piece, object]) => (_x, _y, _z) => {
				piece.forEach((e, x) => {
					e.forEach((e, y) => {
						e.forEach((e, z) => {
							if (map[x + _x][y + _y][z + _z] == piece)
								map[x + _x][y + _y][z + _z] = false
							// scene.remove(object)
						})
					})
				})
			}
			let draw = (map) => {
				for( var i = scene.children.length - 1; i >= 0; i--) {
					obj = scene.children[i]
					if (obj instanceof THREE.Mesh)
						scene.remove(obj)
				}
				map.forEach( (e,x) => {
					e.forEach( (e,y) => {
						e.forEach( (e,z) => {
							if (e) {
								let geometry = new THREE.BoxGeometry( 1, 1, 1 )
								geometry.translate(0.5, 0.5, 0.5)
								let material = new THREE.MeshPhongMaterial( {
									color: new THREE.Color(x / 127, y / 127, z / 127),
									// map: texture,
									// wireframe: true
								} )
								let cube = new THREE.Mesh( geometry, material )
								cube.position.set(x, y, z)
								cube.castShadow = true
								cube.receiveShadow = true
								scene.add( cube )
							}
						})
					})
				})
			}
			let _process = pieces.map( f ).map( (e,i) => {
				return () => {
					let x = y = z = 0
					let seuil = 0
					return () => new Promise( (res, rej) => {
						console.log('new Promise', x, y, z)
						let _piece = data(e[0])(x, y, z)
						let _map = data(map)(0, 0, 0)

						write(map, e)(x, y, z)

						// console.log(data(map)(0, 0, 0), _piece + _map)
						// console.log(data(map)(0, 0, 0) == _piece + _map)

						setTimeout(() => {
							if (data(map)(0, 0, 0) == _piece + _map) {
								res()
							}
							else {
								remove(map, e)(x, y, z)
								draw(map)

								if (x < seuil)
									x += 1
								else {
									x = 0
									if (y < seuil)
										y += 1
									else {
										y = 0
										if (z < seuil)
											z += 1
										else {
											z = 0
											seuil += 1
										}
									}
								}

								rej()
							}
						}, 200)
					})
				}
			})
			__process = _process.map( f => f() )
			let __ = (i) => {
				if (__process[i]) {
					let p = __process[i]().then(() => {
						__process[i + 1] = _process[i + 1]()
						__(i + 1)
					}).catch(() => __(i))
				} else {
					console.log('DONE')
				}
			}

			// draw(map)
			__(0)
			//

			//
			// for (let i = 0; i < 10; i += 1) {
			// 	for (let j = 0; j < 10; j += 1) {
			// 		let cube = new THREE.Mesh( geometry, material )
			// 		cube.position.set( i, 0, j)
			// 		cube.castShadow = true
			// 		cube.receiveShadow = true
			// 		scene.add( cube )
			// 	}
			// }
			//
			// scene.children.forEach( child => scene.remove(child))
			// console.log(scene)

			// pieces.forEach( p => {
			// 	for (var x = 0; x < p.w; x++) {
			// 		for (var y = 0; y < p.h; y++) {
			// 			for (var z = 0; z < p.d; z++) {
			// 				let material = new THREE.MeshPhongMaterial( {
			// 					color: new THREE.Color(x, y, z),
			// 					// wireframe: true
			// 				} )
			// 				let cube = new THREE.Mesh( geometry, material )
			// 				cube.position.set( x - 0.5, y + 1, z - 0.5)
			// 				cube.castShadow = true
			// 				cube.receiveShadow = true
			// 				scene.add( cube )
			// 			}
			// 		}
			// 	}
			// })

			// var loader = new THREE.OBJLoader();

			// load a resource
			// console.log(loader.parse('v 0.123 0.234 0.345'))
			// scene.add( loader.parse('v 0.123 0.234 0.345') )

// 			let s = `
// # OBJ file created by ply_to_obj.c
// #
// g Object001
//
// v  0  0  0
// v  1  0  0
// v  1  1  0
// v  0  1  0
// v  0.5  0.5  1.6
//
// f  5  2  3
// f  4  5  3
// f  6  3  2
// f  5  6  2
// f  4  6  5
// f  6  4  3
// `
			// let o = loader.parseText(s)
			//
			// loader.load('models/seahorse.obj', function (o) {
			// 	let material = new THREE.MeshPhongMaterial( {
			// 		color: 0xf50000,
			// 		// transparent: true,
			// 		// wireframe: true
			// 	} )
			//
			// 	o.position = new THREE.Vector3(0, 0, 0)
			// 	// o.traverse( child => {
			// 	// 	if ( child instanceof THREE.Mesh ) {
			// 	// 		child.material = material
			// 	// 		child.castShadow = true
			// 	// 		child.receiveShadow = true
			// 	// 	}
			// 	// })
			//
			// 	console.log(o)
			// 	scene.add( o )
			// 	var gui = new dat.GUI();
			// 	gui.add(o.position, 'x', -1000, 1000);
			// 	gui.add(o.position, 'y', -1000, 1000);
			// 	gui.add(o.position, 'z', -1000, 1000);
			// })
			//
			// let o = loader.parse(s)
			// let material = new THREE.MeshPhongMaterial( {
			// 	color: 0xf50000,
			// 	// transparent: true,
			// 	// wireframe: true
			// } )

			// o.position = new THREE.Vector3(0, 0, 0)
			// o.traverse( child => {
			// 	if ( child instanceof THREE.Mesh ) {
			// 		child.material = material
			// 		child.castShadow = true
			// 		child.receiveShadow = true
			// 	}
			// })

			// console.log(o)
			// scene.add( o )
			// var gui = new dat.GUI();
			// gui.add(o.position, 'x', -1000, 1000);
			// gui.add(o.position, 'y', -1000, 1000);
			// gui.add(o.position, 'z', -1000, 1000);
			//
			// //
			//
			// let characters = Object.keys(this.ts._personae).map( k => Object.assign(this.ts._personae[k], {
			// 	texture: 'red_headphones',
			// 	relationships: [],
			// 	particularities: [],
			// }))
			// characters.forEach( (e, i) => {
			// 	let name = e._name
			//
			// 	if (e.texture)
			// 		var texture = e.texture.toLowerCase()
			//
			// 	let c = new Character({
			// 		name: name,
			// 		texture: `./assets/${texture}.png`,
			// 		fatness: (e.particularities.find(e => e == 'Fat') ? 1.5 : 1),
			// 		tallness: (e.particularities.find(e => e == 'Tall') ? 1.5 : 1)
			// 	})
			//
			// 	if (name == "World") {
			// 		scene.mainCharacter = c
			// 		mainCharacter = e
			// 	}
			//
			// 	if (e.relationships.length != 0) {
			// 		let d = document.createElement('div')
			// 		d.style['position'] = 'absolute'
			// 		d.style['width'] = '150px'
			// 		d.style['height'] = '80px'
			// 		d.style['border'] = '1px solid black'
			// 		d.style['background-color'] = 'white'
			// 		d.style['top'] = `${Math.floor(i / 8) * 120 + 120}px`
			// 		d.style['left'] = `${Math.floor(i % 8) * 120 + 100}px`
			// 		d.id = name
			// 		d.innerHTML = `
			// 		${name}<br>
			// 		${e.age}
			// 		`
			//
			// 		tree.push(d)
			// 		this.$.data.appendChild(d)
			// 	}
			//
			// 	c.translateX( Math.floor(i / 4) )
			// 	c.translateZ( Math.floor(i % 4) - 1)
			// 	update_stack.push(c.update.bind(c))
			// 	scene.add(c)
			// })


		},
	});
	</script>
</dom-module>
